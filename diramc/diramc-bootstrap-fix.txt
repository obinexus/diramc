/* 
 * DIRAMC Bootstrap & Memory Trace Recovery System
 * OBINexus LIBPOLYCALL2DIRAM Integration
 * Fix for: Memory self-tracing, build system, and bootstrap sequence
 */

#ifndef DIRAM_BOOTSTRAP_H
#define DIRAM_BOOTSTRAP_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <time.h>
#include <unistd.h>
#include <sys/types.h>

// Cross-platform compatibility
#if defined(_WIN32) || defined(_WIN64)
    #include <windows.h>
    #include <process.h>
    #define getpid _getpid
    
    // Windows pthread compatibility layer
    typedef CRITICAL_SECTION pthread_mutex_t;
    #define PTHREAD_MUTEX_INITIALIZER {0}
    
    static inline int pthread_mutex_init(pthread_mutex_t *mutex, void *attr) {
        InitializeCriticalSection(mutex);
        return 0;
    }
    
    static inline int pthread_mutex_destroy(pthread_mutex_t *mutex) {
        DeleteCriticalSection(mutex);
        return 0;
    }
    
    static inline int pthread_mutex_lock(pthread_mutex_t *mutex) {
        EnterCriticalSection(mutex);
        return 0;
    }
    
    static inline int pthread_mutex_unlock(pthread_mutex_t *mutex) {
        LeaveCriticalSection(mutex);
        return 0;
    }
    
    // Windows clock_gettime implementation
    #ifndef CLOCK_MONOTONIC
    #define CLOCK_MONOTONIC 1
    #endif
    
    static int clock_gettime(int clk_id, struct timespec* ts) {
        LARGE_INTEGER freq, count;
        QueryPerformanceFrequency(&freq);
        QueryPerformanceCounter(&count);
        ts->tv_sec = (time_t)(count.QuadPart / freq.QuadPart);
        ts->tv_nsec = (long)(((count.QuadPart % freq.QuadPart) * 1000000000ULL) / freq.QuadPart);
        return 0;
    }
#else
    #include <pthread.h>
#endif

// DIRAM Constants
#define DIRAM_MAX_HEAP_EVENTS 3
#define DIRAM_TRACE_LOG_PATH "logs/diram_trace.log"
#define DIRAM_GUARD_PATTERN 0xDEADBEEF5AFE600D
#define DIRAM_BOOTSTRAP_MAGIC 0x4449524D  // "DIRM"

// Error codes
typedef enum {
    DIRAM_ERR_NONE = 0,
    DIRAM_ERR_HEAP_CONSTRAINT = 0x1001,
    DIRAM_ERR_MEMORY_EXHAUSTED = 0x1002,
    DIRAM_ERR_BOUNDARY_VIOLATION = 0x1003,
    DIRAM_ERR_PID_MISMATCH = 0x1004,
    DIRAM_ERR_BOOTSTRAP_FAILED = 0x1005,
    DIRAM_ERR_TRACE_INIT_FAILED = 0x1006
} diram_error_code_t;

// Heap context for constraint tracking
typedef struct {
    uint64_t command_epoch;
    uint32_t event_count;
} diram_heap_context_t;

// Allocation tracking structure
typedef struct {
    void* base_addr;
    size_t size;
    uint64_t timestamp;
    uint32_t heap_events;
    pid_t binding_pid;
    char sha256_receipt[65];
    uint32_t magic;  // Bootstrap verification
} diram_allocation_t;

// Bootstrap state
typedef struct {
    bool initialized;
    bool trace_enabled;
    pthread_mutex_t init_mutex;
    FILE* trace_log;
    void* bootstrap_memory;  // Pre-allocated bootstrap pool
    size_t bootstrap_size;
    uint32_t bootstrap_magic;
} diram_bootstrap_state_t;

// Global bootstrap state
static diram_bootstrap_state_t g_bootstrap = {
    .initialized = false,
    .trace_enabled = false,
    .init_mutex = PTHREAD_MUTEX_INITIALIZER,
    .trace_log = NULL,
    .bootstrap_memory = NULL,
    .bootstrap_size = 0,
    .bootstrap_magic = DIRAM_BOOTSTRAP_MAGIC
};

// Thread-local heap context
static __thread diram_heap_context_t heap_ctx = {0, 0};

/* ==================== BOOTSTRAP FUNCTIONS ==================== */

/**
 * Initialize DIRAM bootstrap sequence
 * This MUST be called before any allocation attempts
 */
int diram_bootstrap_init(void) {
    pthread_mutex_lock(&g_bootstrap.init_mutex);
    
    if (g_bootstrap.initialized) {
        pthread_mutex_unlock(&g_bootstrap.init_mutex);
        return 0;
    }
    
    // Phase 1: Pre-allocate bootstrap memory pool
    // This avoids chicken-egg problem of needing memory to track memory
    g_bootstrap.bootstrap_size = 1024 * 1024;  // 1MB bootstrap pool
    g_bootstrap.bootstrap_memory = malloc(g_bootstrap.bootstrap_size);
    
    if (!g_bootstrap.bootstrap_memory) {
        fprintf(stderr, "FATAL: Bootstrap memory allocation failed\n");
        pthread_mutex_unlock(&g_bootstrap.init_mutex);
        return DIRAM_ERR_BOOTSTRAP_FAILED;
    }
    
    // Phase 2: Initialize trace log (using bootstrap memory if needed)
    int trace_result = diram_init_trace_log_bootstrap();
    if (trace_result < 0) {
        fprintf(stderr, "WARNING: Trace log initialization failed, continuing without tracing\n");
        g_bootstrap.trace_enabled = false;
    } else {
        g_bootstrap.trace_enabled = true;
        fprintf(g_bootstrap.trace_log, "# DIRAM Bootstrap Initialized\n");
        fprintf(g_bootstrap.trace_log, "# PID: %d\n", getpid());
        fprintf(g_bootstrap.trace_log, "# Bootstrap Pool: %p (%zu bytes)\n", 
                g_bootstrap.bootstrap_memory, g_bootstrap.bootstrap_size);
        fflush(g_bootstrap.trace_log);
    }
    
    g_bootstrap.initialized = true;
    pthread_mutex_unlock(&g_bootstrap.init_mutex);
    
    return 0;
}

/**
 * Initialize trace log during bootstrap
 * Uses pre-allocated memory to avoid allocation dependencies
 */
int diram_init_trace_log_bootstrap(void) {
    // Create logs directory if it doesn't exist
    #ifdef _WIN32
        CreateDirectory("logs", NULL);
    #else
        mkdir("logs", 0755);
    #endif
    
    g_bootstrap.trace_log = fopen(DIRAM_TRACE_LOG_PATH, "a");
    if (!g_bootstrap.trace_log) {
        return DIRAM_ERR_TRACE_INIT_FAILED;
    }
    
    // Enable line buffering for immediate visibility
    setvbuf(g_bootstrap.trace_log, NULL, _IOLBF, 0);
    
    // Write bootstrap header
    time_t now = time(NULL);
    fprintf(g_bootstrap.trace_log, "\n# ===== DIRAM TRACE LOG =====\n");
    fprintf(g_bootstrap.trace_log, "# Timestamp: %s", ctime(&now));
    fprintf(g_bootstrap.trace_log, "# Format: TIMESTAMP|PID|OPERATION|ADDRESS|SIZE|SHA256|TAG\n");
    fprintf(g_bootstrap.trace_log, "# Bootstrap Magic: 0x%X\n", g_bootstrap.bootstrap_magic);
    fflush(g_bootstrap.trace_log);
    
    return 0;
}

/* ==================== MEMORY TRACING FUNCTIONS ==================== */

/**
 * Compute SHA-256 receipt for allocation
 * Simplified implementation for demonstration
 */
void diram_compute_receipt(diram_allocation_t* alloc, const char* tag) {
    // In production, use OpenSSL or similar
    // This is a deterministic pseudo-hash for testing
    uint64_t hash = (uint64_t)alloc->base_addr ^ alloc->size ^ alloc->timestamp;
    
    for (int i = 0; i < 32; i++) {
        uint8_t byte = (hash >> ((i % 8) * 8)) & 0xFF;
        sprintf(&alloc->sha256_receipt[i * 2], "%02x", byte);
    }
    alloc->sha256_receipt[64] = '\0';
}

/**
 * Check heap constraint (e(x) = 0.6, max 3 events)
 */
static int check_heap_constraint(uint64_t current_epoch) {
    if (heap_ctx.command_epoch != current_epoch) {
        heap_ctx.event_count = 0;
        heap_ctx.command_epoch = current_epoch;
    }
    
    if (heap_ctx.event_count >= DIRAM_MAX_HEAP_EVENTS) {
        return -1;  // Constraint violation
    }
    
    heap_ctx.event_count++;
    return 0;
}

/**
 * Traced allocation with bootstrap support
 */
diram_allocation_t* diram_alloc_traced(size_t size, const char* tag) {
    // Ensure bootstrap is initialized
    if (!g_bootstrap.initialized) {
        if (diram_bootstrap_init() != 0) {
            return NULL;
        }
    }
    
    // Get timestamp for epoch checking
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    uint64_t current_epoch = ts.tv_sec;
    
    // Check heap constraint
    if (check_heap_constraint(current_epoch) < 0) {
        if (g_bootstrap.trace_enabled && g_bootstrap.trace_log) {
            fprintf(g_bootstrap.trace_log, 
                    "%lu|%d|CONSTRAINT_VIOLATION|NULL|%zu|NONE|%s\n",
                    (unsigned long)ts.tv_sec, getpid(), size, tag ? tag : "untagged");
            fflush(g_bootstrap.trace_log);
        }
        return NULL;
    }
    
    // Allocate tracking structure
    diram_allocation_t* alloc = malloc(sizeof(diram_allocation_t));
    if (!alloc) {
        heap_ctx.event_count--;  // Rollback
        return NULL;
    }
    
    // Perform actual allocation
    alloc->base_addr = malloc(size);
    if (!alloc->base_addr) {
        free(alloc);
        heap_ctx.event_count--;  // Rollback
        return NULL;
    }
    
    // Initialize allocation metadata
    alloc->size = size;
    alloc->timestamp = (uint64_t)ts.tv_sec * 1000000000ULL + ts.tv_nsec;
    alloc->heap_events = heap_ctx.event_count;
    alloc->binding_pid = getpid();
    alloc->magic = DIRAM_BOOTSTRAP_MAGIC;
    
    // Generate receipt
    diram_compute_receipt(alloc, tag);
    
    // Write trace entry
    if (g_bootstrap.trace_enabled && g_bootstrap.trace_log) {
        fprintf(g_bootstrap.trace_log, "%lu|%d|ALLOC|%p|%zu|%s|%s\n",
                alloc->timestamp, alloc->binding_pid,
                alloc->base_addr, alloc->size,
                alloc->sha256_receipt,
                tag ? tag : "untagged");
        fflush(g_bootstrap.trace_log);
    }
    
    return alloc;
}

/**
 * Free traced allocation
 */
void diram_free_traced(diram_allocation_t* alloc) {
    if (!alloc) return;
    
    // Verify magic number
    if (alloc->magic != DIRAM_BOOTSTRAP_MAGIC) {
        fprintf(stderr, "ERROR: Invalid allocation magic (corruption?)\n");
        return;
    }
    
    // Verify PID binding
    if (alloc->binding_pid != getpid()) {
        // Fork detected
        return;
    }
    
    // Get timestamp for trace
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    uint64_t timestamp = (uint64_t)ts.tv_sec * 1000000000ULL + ts.tv_nsec;
    
    // Write trace entry
    if (g_bootstrap.trace_enabled && g_bootstrap.trace_log) {
        fprintf(g_bootstrap.trace_log, "%lu|%d|FREE|%p|%zu|%s|traced\n",
                timestamp, getpid(),
                alloc->base_addr, alloc->size,
                alloc->sha256_receipt);
        fflush(g_bootstrap.trace_log);
    }
    
    // Free memory
    free(alloc->base_addr);
    
    // Clear and free tracker
    memset(alloc, 0, sizeof(diram_allocation_t));
    free(alloc);
}

/* ==================== SELF-TEST FUNCTIONALITY ==================== */

/**
 * Self-test to verify diramc can trace its own memory
 */
int diram_self_test(void) {
    printf("=== DIRAM Self-Test: Memory Bootstrap & Tracing ===\n");
    
    // Test 1: Bootstrap initialization
    printf("Test 1: Initializing bootstrap...\n");
    int init_result = diram_bootstrap_init();
    if (init_result != 0) {
        printf("FAILED: Bootstrap initialization failed with code %d\n", init_result);
        return -1;
    }
    printf("PASSED: Bootstrap initialized\n");
    
    // Test 2: Allocate and trace memory
    printf("Test 2: Testing traced allocation...\n");
    diram_allocation_t* test_alloc = diram_alloc_traced(1024, "self_test");
    if (!test_alloc) {
        printf("FAILED: Traced allocation failed\n");
        return -1;
    }
    printf("PASSED: Allocated 1024 bytes at %p\n", test_alloc->base_addr);
    printf("       SHA-256: %s\n", test_alloc->sha256_receipt);
    
    // Test 3: Write pattern to verify memory
    printf("Test 3: Writing test pattern...\n");
    memset(test_alloc->base_addr, 0xAB, test_alloc->size);
    unsigned char* verify = (unsigned char*)test_alloc->base_addr;
    if (verify[0] != 0xAB || verify[test_alloc->size - 1] != 0xAB) {
        printf("FAILED: Memory pattern verification failed\n");
        return -1;
    }
    printf("PASSED: Memory pattern verified\n");
    
    // Test 4: Heap constraint test (max 3 allocations)
    printf("Test 4: Testing heap constraints...\n");
    diram_allocation_t* alloc2 = diram_alloc_traced(512, "test2");
    diram_allocation_t* alloc3 = diram_alloc_traced(256, "test3");
    diram_allocation_t* alloc4 = diram_alloc_traced(128, "test4_should_fail");
    
    if (alloc2 && alloc3 && !alloc4) {
        printf("PASSED: Heap constraint enforced (3 events max)\n");
    } else {
        printf("FAILED: Heap constraint not working properly\n");
        return -1;
    }
    
    // Test 5: Free and trace
    printf("Test 5: Testing traced deallocation...\n");
    diram_free_traced(test_alloc);
    diram_free_traced(alloc2);
    diram_free_traced(alloc3);
    printf("PASSED: Deallocations traced\n");
    
    // Test 6: Verify trace log exists
    printf("Test 6: Verifying trace log...\n");
    if (access(DIRAM_TRACE_LOG_PATH, F_OK) == 0) {
        printf("PASSED: Trace log exists at %s\n", DIRAM_TRACE_LOG_PATH);
    } else {
        printf("WARNING: Trace log not found (may be disabled)\n");
    }
    
    printf("\n=== DIRAM Self-Test COMPLETED SUCCESSFULLY ===\n");
    return 0;
}

#endif /* DIRAM_BOOTSTRAP_H */

/* ==================== MAIN TEST DRIVER ==================== */

#ifdef DIRAM_TEST_BUILD

int main(int argc, char* argv[]) {
    printf("DIRAM Bootstrap & Memory Trace Recovery System\n");
    printf("OBINexus LIBPOLYCALL2DIRAM Integration\n");
    printf("PID: %d\n\n", getpid());
    
    // Run self-test
    int result = diram_self_test();
    
    if (result == 0) {
        printf("\nDIRAM is now ready for integration with LibPolyCall.\n");
        printf("The memory tracing system is operational and can bootstrap itself.\n");
    } else {
        printf("\nERROR: DIRAM self-test failed. Check logs for details.\n");
    }
    
    return result;
}

#endif /* DIRAM_TEST_BUILD */